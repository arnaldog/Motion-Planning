\section{Descripción del Algoritmo}

%%% INTRODUCCION PRIMERO

En esta investigación, se usó el algoritmo de ``Optimización por Enjambre de Partículas'' (Particle Swarm Optimization)\cite{KennedyEberhart}, el cual consiste en buscar una solución óptima a un problema dentro de un espacio de búsqueda grande, usando un enjambre de partículas, las que individualmente representan una solución distinta según en la posición en que se encuentran.\\

	Éstas partículas tienen la capacidad de moverse por este espacio de búsqueda, y hacerlo con una cierta velocidad que pueden variar según su entorno. Además estas partículas tienen una memoria que les permite saber siempre cual ha sido su mejor ubicación dentro del espacio de búsqueda.\\
	Luego, las partículas se comunican entre ellas para informar la calidad de su posición para conocer cuál tiene la mejor posicion, con esta informacion las demás partículas deben decidir si moverse en dirección de la mejor partícula, dirigirse hacia su mejor posicion individual según su memoria, o moverse aleatoriamente a otra posición.\\

	La decisión o probabilidad de acercarse a la mejor de todas las partículas o no, depende de ciertos parámetros configurables del algoritmo los cuales, en este documento se presentan de la siguiente manera:\\

	\begin{small}
		$\phi_{p}$ =	nivel de importancia para moverse hacia la mejor posicion\\
						individual de la partícula, según su memoria. \\
		$\phi_{g}$ =	nivel de importancia para moverse hacia la mejor partícula\\
						dentro del enjambre. \\
		$\omega$ =		nivel de importancia para moverse hacia una posicion aleatoria. \\
	\end{small}

%%% REPRESENTACION PARA EL ENJAMBRE

% ENJAMBRE
\subsection{Representación del enjambre}
El enjambre de partículas corresponde al conjunto de $S$ partículas, donde cada partícula es una eventual solución (ruta) y corresponde a una ruta a la que se le calcula una velocidad de movimiento respecto a su mejor posición histórica y respecto a la mejor posición global determinada en la inicialización y posteriormente determinada durante la iteración.
El objetivo del Global Path Planning PSO es que cada partícula tome movimientos relativos al mejor del grupo y a su propia información de mejor posición.\\

	El enjambre además de la lista de partículas, tiene en memoria cuál ha sido la mejor partícula de todo el proceso de búsqueda, con ello, su posición (la solución) y su velocidad.

%PARTICULA
\subsection{Representación de la partícula y de las soluciones}
Una partícula corresponde a una eventual solución del problema, es decir una partícula $s$ es una ruta que describe el camino a seguir desde un nodo de inicio $p_{0} = a$ al nodo de término $p_{l} = b$ dentro de un espacio bidimensional $C$ de tamaño $m \times n$. Así, las rutas se definen como:

	\begin{eqnarray}
		p = \{ p_0, p_1, ..., p_n : p_i \in C, p_0 = a, p_n = p_{l} = b, n \leq mn\}
	\end{eqnarray}

Luego, una ruta, debido a la naturaleza del problema tiene una longitud variable ya que distintas rutas pueden ser de distinta longitud.\\

	Esto crea el problema de formular una representación óptima para PSO ya que se necesita introducir el concepto de velocidad, y con ello, el concepto de dos soluciones se puedan ``acercar'' para de cierta manera ``parecerse'' a la cual se está acercando.\\

	Para explicar mejor el problema de la representación, se supone el siguiente ejemplo:\\
	Se tienen 2 rutas del mismo largo $n=4$, cada elemento de la partícula representa una casilla del mapa a recorrer, además ambas deben tener el mismo elemento al principio y al final ya que representan el inicio y el final del recorrido.

	\begin{eqnarray}
		r_{1} = \{ 1, 2, 4, 5\} \\
		r_{2} = \{ 1, 7, 8, 5\}
	\end{eqnarray}

	Si la particula representada por la ruta $r_{2}$ reporta un camino de mejor calidad que $r_{1}$, una forma para hacer que la particula $r_{1}$ se acerque para parecerse a $r_{2}$ y con ello intentar mejorar su calidad es modificando cada elemento de $r_{1}$ para que tome el valor, como ejemplo:\\

	\begin{eqnarray}
		r_{1}_{i} = \left \lceil \frac{(r_{1}_{i} + r_{2}_{i})}{2} \right \rceil, \forall i = 1 : 4
	\end{eqnarray}

	Es decir, el promedio entre los valores individuales (aproximado hacia arriba para mantener concordancia con el espacio discreto), con esto las rutas finalmente quedan como:\\

	\begin{eqnarray}
		r_{1}' = \{ 1, 5, 6, 5\} \\
		r_{2} = \{ 1, 7, 8, 5\}
	\end{eqnarray}

	Así, la particula $r_{1}$ está mas cerca de $r_{2}$.

	El real problema nace debido a la naturaleza del problema, no se puede suponer que las rutas sean todas de la misma longitud, algunas seran más largas que otras y serán mejores ya que evitan mas obstáculos.\\

	Para solucionar esta problemática se introduce el concepto de ``puntos de apoyo'' o ``pivotes'', para poder redefinir el concepto de partícula.

	Usando pivotes, se crean submetas por las cuales las rutas deben pasar obligatoriamente antes de seguir a la siguiente submeta (siguiente pivote), una vez visitados todos los pivotes, se debe buscar una ultima subruta que comience en el ultimo pivote y el punto final deseado.

	Gracias a los pivotes la creacion de rutas completas es simplificada a la busqueda de rutas mas cortas y fáciles de resolver cuya característica más importante es que una partícula $s$ puede ser definida como una secuencia de pivotes $P_{v}$ de longitud constante $n$:

	\begin{eqnarray}
		p = \{ p_0, p_1, ..., p_n : p_i \in P_{v}, p_0 = a, p_n = p_{l} = b, n = #P_{v}\}
	\end{eqnarray}

	Con esta representación, las partículas efectivamente pueden moverse dentro de una dimension fija, y acercarse para poder imitar a otras partículas con mejores características.\\

	Por ejemplo, una particula $s1$  representando una ruta mas corta que una partícula $s2$, la partícula $s2$ puede acercar sus pivotes ($p_{0}$, $p_{1}$, $p_{2}$, $p_{3}$) a los de la partícula $s1$ para poder asi, mejorar su calidad al parecerse a $s1$, generando una particula $s3$ representada como una ruta de largo intermedio entre $s1$ y $s2$, como se muestra en la Figura \ref{fig:pivots_explained}.

	\begin{figure}
		\includegraphics[width = 250]{img/pivots_explained.pdf} % Or .pdf
		\caption{Acercamiento de partículas usando pivotes}
		\label{fig:pivots_explained}
	\end{figure}

%%%%%% ARNALDO: COMPLETA ACA TU PARTE DE BEZIER Y HERMITE, pondre como titulo tentativo "generacion de rutas, etc..."

\subsection{Generacion de rutas mediante pivotes}

de longitud fija $k$ de puntos $q \in \mathbb{N}^2$ con su velocidad $v$ de igual longitud $k$ corresponde a la configuración $s = (x, p, v)$ donde $x$ es la posición instantanea, $p$ la mejor posición histórica y $v$ la velocidad de la partícula.
	\begin{eqnarray}
		x = \{ a, q_2, \ldots q_{k-1}, b \} \\
		v = \{ v_0, \ldots, v_k \}
	\end{eqnarray}
En este caso $x$ y $p$ obviamente tienen los mísmos puntos al comienzo y al final dado que representan una solución candidata donde los puntos de origen y final representan a las regiones inicial y objetivo respectivamente.

La posición $x$ de la partícula $s \in S$ corresponde a un conjunto de puntos que interpolados o aproximados entre sí constituyen la ruta $r$ mediante diferentes métodos de interpolación o aproximación. Para esta investigación se realizaron implementaciones de los métodos de interpolación paramétrica Cubic Hermité Splines y Cubic Bezier Splines, dado los puntos sugeridos por cada particula. Se realizaron experimentos con B Splines pero se descartaron porque no aproxima desde la región inicial ni a la región objetivo aunque pueden ser utilizadas otras técnicas para satisfacer tal condición pero introducen complejidad  adicional para realizar comparaciones de los métodos.
La representación de la ruta está dada entonces por el conjunto de polinomios interpoladores o aproximadores sobre los pares sucesivos de los $k$ puntos $q$ definidos como posición en la partícula $s$. Las formas
\paragraph{Cubic Bezier Splines}  Esta aproximación es utilizada para mantener la propiedad de cobertura de area mínima (convex hull) de los polinomios generados por cada par de puntos asegurando que las rutas generadas satisfagan la restricción de preservar la frontera de entorno de operación. Cada polinomio $i$ generado entre los puntos $i$ e $i+1$ se genera a partir de la expresión
\begin{small}
\begin{equation}
[x_i(t), y_i(t)] = \left[\begin{array}{c}
			t^3 \\ t^2 \\ t \\ 1
			\end{array}
			\right]^T \left[
			\begin{array}{rrrr}
			-1 &  3 & -3 &  1 \\
			 3 & -6 &  3 &  0 \\
			-3 &  3 &  0 &  0 \\
			 1 &  0 &  0 &  0
			\end{array}
		\right] \left[
			\begin{array}{c}
			 q_{i-1} \\
			 q_{i} \\
			 q_{i+1} \\
			 q_{i+2}
			 \end{array}
		\right]
\end{equation}
\end{small}

\paragraph{Cubic Hermite Splines} Esta interpolación consta además de una variante en la representación de la partícula $s$ la cual considera, además de los puntos en el entorno de operación, la gradiente de cada punto $(\nabla q)$ para determinar la forma de la ruta generada, por tanto $x_h = (x, \nabla x)$. Cada polinomio $i$ generado entre los puntos $i$ e $i+1$ se genera a partir de la expresión:
\begin{small}
\begin{equation}
[x_i(t), y_i(t)] = \left[\begin{array}{c}
			t^3 \\ t^2 \\ t \\ 1
			\end{array}
			\right]^T \left[
			\begin{array}{rrrr}
			 2 & -2 &  1 &  1 \\
			-3 &  3 & -2 & -1 \\
			 0 &  0 &  1 &  0 \\
			 1 &  0 &  0 &  0
			\end{array}
		\right] \left[
			\begin{array}{r}
			 q_{i} \\
			 q_{i+1} \\
			 \nabla q_{i} \\
			 \nabla q_{i+1}
			 \end{array}
		\right]
\end{equation}
\end{small}
Todas las combinaciones de rutas posibles dentro del mapa representan el dominio de cada ruta ya que estas son generadas a partir de puntos y gradientes descritas por la partícula.

La longitud de la ruta está dada por
\begin{equation}
\ell =\sum_{i=1}^{k-1} \int_{0}^{1}\sqrt{\left[x_{i}'(t)\right]^2 + \left[y_{i}'(t)\right]^2} dt
\end{equation}

Cada posición $x$ y velocidad $v$ es generada pseudo aleatoreamente dentro del encuadre del entorno de operación y son entendidas como pivotes o puntos de control (según el método utilizado).
La actualización de la posición corresponde a la generación de nuevas rutas que pasen por los pivotes o puntos de control modificados respecto a la información que se tenga en el enjambre.
La función objetivo
	\begin{equation}
		\min F(\ell) = \ell + NC(1 + {\ell}^\alpha)
	\end{equation}
donde  $ C$ es el número de colisiones y $\alpha$ es el nivel de penalización por rutas cortas con colisiones.

Bajo esta representación todas las rutas tienen largos distintos pero las longitudes de las posiciones y velocidades permanecen constantes lo que significa gran comodidad para operar durante la ejecución del algoritmo

La actualización de la velocidad de la partícula $s$ está dada por
	\begin{eqnarray}
	 v_{i+1} = \omega v_i + \rho_g\phi_g (g - x_i) + \rho_p\phi_g (p_i- x_i) \\
	  x_{i+1} =  x_i +  v_i
	\end{eqnarray}
donde los parámetros mencionados son: $\omega$ que pondera el efecto de la velocidad actual, $\phi_g$ parámetro para favorecer la explotación,  $\phi_p$ parámetro para favorecer la exploración, $\rho_g, \rho_p \sim U(0,1)$, $g$ la mejor posición global, $p_i$ la mejor posición de la partícula $i$, $x_i$ posición de la partícula $i$.

%%%% OPERADORES DE RUTA
Para realizar las operaciones se consideró una definición especial para restar, sumar y multiplicar posiciones y velocidades las que se realizan punto a punto, lo que produce incrementos o decrementos en los puntos dentro del entorno de operación para realizar la exploración y explotación necesaria para el algoritmo.

%%% ALGORITMO PSO
El algoritmo PSO consta de una fase de inicialización, luego una fase de iteración para terminar con la finalización
Inicialización del enjambre
\begin{center}
\begin{algorithm}[H]% <- necesario
\SetLine \KwData{$S, \omega, \Phi_g, \Phi_p$, $g \leftarrow $ MAX\_INT}
\KwResult{Mejor particula $s_i$. }
\linesnumbered
\SetVline
\For{$i=1$ \KwTo $S$ }
{
	$x_i = $ \text{Inicializar posición aleatoreamente}\;
	$p_i \leftarrow x_i$\;
	$v_i = $ \text{Inicializar velocidad aleatoreamente}\;
	\If{$f(p_i) < f(g)$}{
		$g \leftarrow p_i$
	}

}
\caption{Inicialización PSO}
\end{algorithm}
\end{center}

Iteración del enjambre
\begin{center}
\begin{algorithm}[H]% <- necesario
\SetLine \KwData{$S, \omega, \Phi_g, \Phi_p, I$}
\KwResult{Mejor particula $g$. }
\linesnumbered
$i = 0$
\While{$ i < I $}{
	\For{$i=1$ \KwTo $S$}
	{
		$ r_p, r_g \sim U(0,1)$\;
		$ v_i \leftarrow \omega v_i + \Phi_p r_p (p_i - x_i) + \Phi_g r_g(g - x_i)$\;
		$ x_i \leftarrow x_i + v_i $\;
		\If{$ f(r_i) < f(p_i)$}
		{
			$p_i \leftarrow x_i$\;
			\If{$f(p_i) < f(g)$}
			{
				$g \leftarrow p_i$\;
			}
		}
	}
	$i=i+1$\;
}
\Return $g$ \;
\caption{Iteración PSO}
\end{algorithm}
\end{center}
